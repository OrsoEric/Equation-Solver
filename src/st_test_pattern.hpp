/****************************************************************
**	OrangeBot Project
*****************************************************************
**        /
**       /
**      /
** ______ \
**         \
**          \
*****************************************************************
**	St_test_pattern
*****************************************************************
**  Array filled with test patterns to be fed to the unit test
**	Meant to test the various features of the tokenizer, the treeificator aggregator
****************************************************************/

//serialization/deserialization
#include <iostream>
#include <sstream>
//save/load
#include <fstream>
//Tree class
#ifndef TREE_H_
	#include "tree.hpp"
#endif
//Equation class
#ifndef EQUATION_H_
	//Needs definitions for the Equation class
	#include "equation.h"
#endif

/**********************************************************************************
**  NAMESPACE
**********************************************************************************/

//! @namespace custom namespace
namespace User
{

/************************************************************************************/
//! @struct      St_test_pattern
/************************************************************************************/
//!	@author     Orso Eric
//! @version    2022-06-DD
//! @brief      xxx
//! @copyright  BSD 3-Clause License Copyright (c) 2020, Orso Eric
//! @details
//! \n This structur translates an equation in string form into an equation in tree form
//! \n 2022-08-09 Implements Unary +/- Operators
//! \n 2022-08-09 Functions work out of the box. It's a symbol with leaves. It's parsed correctly.
//! \n 2023-05-16
/************************************************************************************/

//structure holding the test patterns. I have the source, and the expected outputs, and they have to match.
struct St_test_pattern
{
		//Structure Members
	//User adds a note to the test pattern explaining what it's testing
	std::string s_user_note;
	//Equation fed to the parser
	std::string s_equation;
	//Expected result of the parser. true=FAIL | false=PASS
	bool x_fail;
	//Expected string tokens after a successful parse
	std::vector<std::string> as_string_token;
	//vector of token structures
	std::vector<User::Equation::Token> ast_token;
	//Expected tree structure after a successful parse
	std::vector<User::Tree<User::Equation::Token>::St_minimal_node> ast_minimal_node;
	//Reverse translation from tree back to string
	std::string s_equation_decoded;

		//Structure Methods
	//fill St_test_pattern from a string equation using Equation::parse
	bool from_string_equation( std::string &irs_user_note, std::string &irs_equation );
	/*
	bool from_string_equation( const char* ipc_equation )
	{
		return from_string_equation( std::string( ipc_equation ) );
	}
	*/
	//Construct a st_test_pattern from a string equation, and append it to an existing vector of test patterns
	static bool append_string_equation( std::vector<St_test_pattern>& irast_test_patterns, std::string &irs_user_note ,std::string &irs_equation );
	static bool append_string_equation( std::vector<St_test_pattern>& irast_test_patterns, const char *ips8_user_note, const char *ips8_equation )
	{
		std::string s_user_note( ips8_user_note );
		std::string s_equation( ips8_equation );
		return append_string_equation( irast_test_patterns, s_user_note, s_equation );
	}
	//Static method in St_test_pattern that saves a vector of St_test_pattern into a csv file
	static bool save(const std::vector<St_test_pattern>& irast_test_patterns, const std::string& s_file_name);
	//Static method in St_test_pattern that loads a csv file generated by save into a vector of St_test_pattern
	static std::vector<St_test_pattern> load(const std::string& s_file_name);

		private:
	//write a Token structure inside a file stream
	static bool save_token( std::ofstream &ircl_file, User::Equation::Token &irst_token );
	//read from file a token and save it in a token structure
	static bool parse_token( std::stringstream &irs_string_stream, User::Equation::Token &orst_token, char &irs8_delimiter );
	//Serialize St_test_pattern into a string
	//to_string( void )
};

//fill St_test_pattern from a string equation using Equation::parse
bool St_test_pattern::from_string_equation( std::string &irs_user_note, std::string &irs_equation )
{
	//parse the equation, get the intermediate token rapresentation
	std::vector<std::string> as_string_token;
	std::vector<User::Equation::Token> ast_token;
	User::Equation cl_equation;
	bool x_fail = cl_equation.parse( irs_equation, as_string_token, ast_token );
	if (x_fail == true)
	{
		std::cerr << "ERR:" << __LINE__ << "\n";
		return x_fail;
	}
	//Get the tree
	std::vector<User::Tree<User::Equation::Token>::St_minimal_node> ast_minimal_node;
	x_fail = cl_equation.get_tree_of_token().get_sorted_payload( ast_minimal_node );
	if (x_fail == true)
	{
		std::cerr << "ERR:" << __LINE__ << "Failed to get St_minimal_node\n";
		return x_fail;
	}
	//Save the decoded equation into the St_test_pattern structure
	this->s_user_note = irs_user_note;
	this->s_equation = irs_equation;
	this->x_fail = x_fail;
	this->as_string_token = as_string_token;
	this->ast_token = ast_token;
	this->ast_minimal_node = ast_minimal_node;
	//Reverse decode the equation into a string
	this->s_equation_decoded = cl_equation.to_string();

	return false;	//OK
}

//Construct a st_test_pattern from a string equation, and append it to an existing vector of test patterns
bool St_test_pattern::append_string_equation( std::vector<St_test_pattern>& orast_test_patterns, std::string &irs_user_note, std::string &irs_equation )
{
	//Construct a virgin St_test_pattern structure
	User::St_test_pattern st_test_pattern;
	//Fill the structure from a string equation
	bool x_fail = st_test_pattern.from_string_equation( irs_user_note, irs_equation );
	if (x_fail == true)
	{
		return true;
	}
	//Append the test pattern to the given vector
	orast_test_patterns.push_back( st_test_pattern );
	return false;	//OK
}

//Static method in St_test_pattern that saves a vector of St_test_pattern into a csv file
bool St_test_pattern::save(const std::vector<St_test_pattern>& irast_test_patterns, const std::string& s_file_name)
{
	//Open a file stream for writing
	std::ofstream cl_file(s_file_name);
	//Check if the file stream is open
	if (cl_file.is_open())
	{
		//Loop through each test pattern in the vector
		for (const auto& test_pattern : irast_test_patterns)
		{
			//Write the user note to the file, followed by a comma
			cl_file << "s_user_note" << ",";
			cl_file << test_pattern.s_user_note << ",";
			//Write the equation to the file, followed by a comma
			cl_file << "s_equation" << ",";
			cl_file << test_pattern.s_equation << ",";
			//Write the fail state to the file, followed by a comma
			cl_file << "x_fail" << ",";
			cl_file << test_pattern.x_fail << ",";
			//Write the size of the token vector to the file, followed by a comma
			cl_file << "as_string_token" << ",";
			cl_file << test_pattern.as_string_token.size() << ",";
			//Loop through each token in the token vector
			for (const auto& token : test_pattern.as_string_token)
			{
				//Write the token string to the file, followed by a comma
				cl_file << token << ",";
			}
			//Write the size of the token vector to the file, followed by a comma
			cl_file << "ast_token" << ",";
			cl_file << test_pattern.ast_token.size() << ",";
			//Loop through each token in the token vector
			for (auto cl_iterator_st_token : test_pattern.ast_token)
			{
				//Marker for each token
				cl_file << "st_token" << ",";
				//Write the token
				bool x_fail = St_test_pattern::save_token( cl_file, cl_iterator_st_token );
				if (x_fail == true)
				{
					std::cerr << "ERR:" << __LINE__ << " | could not save Token\n";
					return false; //OK
				}
			}
			//Write the size of the minimal node vector to the file, followed by a comma
			cl_file << "ast_minimal_node" << ",";
			cl_file << test_pattern.ast_minimal_node.size() << ",";
			//Loop through each minimal node in the minimal node vector
			for (auto cl_iterator_minimal_node : test_pattern.ast_minimal_node)
			{
				//Each minimal node entry has a fixed marker
				cl_file << "st_minimal_node" << ",";
				//Write a token structure inside the file
				bool x_fail = St_test_pattern::save_token( cl_file, cl_iterator_minimal_node.t_payload );
				if (x_fail == true)
				{
					std::cerr << "ERR:" << __LINE__ << " | could not save Token\n";
					return false; //OK
				}
				//Write the index of the father to the file, followed by a comma
				cl_file << cl_iterator_minimal_node.n_index_father << ",";
			}

			cl_file << "s_equation_decoded" << ",";
			//Write the token string to the file, followed by a comma
			cl_file << test_pattern.s_equation_decoded << ",";

			cl_file << "END" << ",";
			//Write a newline character to separate each test pattern
			cl_file << "\n";
		}
	}
	else //If the file stream is not open
	{
		std::cerr << "Error: could not open file " << s_file_name << "\n";
	}
	//Close the file stream
	cl_file.close();

	return false; //OK
}

//! @brief Static method in St_test_pattern that loads a csv file generated by save into a vector of St_test_pattern
std::vector<St_test_pattern> St_test_pattern::load(const std::string& s_file_name)
{
	//Create an empty vector of St_test_pattern to store the loaded data
	std::vector<St_test_pattern> ast_test_patterns;
	//Open a file stream for reading
	std::ifstream ifs(s_file_name);
	//Check if the file stream is open
	if (ifs.is_open())
	{
		std::cout << "Load St_test_pattern vector from: " << s_file_name << "\n";
		//Create a string to store each line of the file
		std::string s_line;
		//Create a string stream to parse each line
		std::stringstream s_string_stream;
		//Create a string to store each token of the line
		std::string s_token;
		//Create a char to store the delimiter character
		char c_delim = ',';
		//Create a St_test_pattern object to store each test pattern
		St_test_pattern st_test_pattern;
		//Create a size_t variable to store the size of the token vector and the minimal node vector
		size_t n_size = 0;
		//Create a User::Equation::Token object to store each payload of the minimal node
		User::Equation::Token st_token;
		//Create a size_t variable to store the index of the father of the minimal node
		size_t n_index_father = 0;
		//Loop through each line of the file until the end of file is reached
		while (std::getline(ifs, s_line))
		{

			std::cout << "Pattern: " << ast_test_patterns.size() << "\n";
			//Clear the string stream and set it to the current line
			s_string_stream.clear();
			s_string_stream.str(s_line);
			//Clear the test pattern object and set its fields to default values
			st_test_pattern = {};

			//Get the user note from the first token of the line
			std::getline(s_string_stream, s_token, c_delim);
			char *s_str_check = "s_user_note";
			if (s_token != s_str_check)
			{
				std::cerr << "ERR:" << __LINE__ << " | could not decode: "<< s_str_check << " | Token: " << s_token << "\n";
				return ast_test_patterns;
			}
			std::getline(s_string_stream, s_token, c_delim);
			st_test_pattern.s_user_note = s_token.c_str();

			//Get the equation from the second token of the line
			std::getline(s_string_stream, s_token, c_delim);
			s_str_check = "s_equation";
			if (s_token != s_str_check)
			{
				std::cerr << "ERR:" << __LINE__ << " | could not decode: "<< s_str_check << " | Token: " << s_token << "\n";
				return ast_test_patterns;
			}
			std::getline(s_string_stream, s_token, c_delim);
			st_test_pattern.s_equation = s_token.c_str();

			//Get the fail state from the third token of the line and convert it to bool
			std::getline(s_string_stream, s_token, c_delim);
			s_str_check = "x_fail";
			if (s_token != s_str_check)
			{
				std::cerr << "ERR:" << __LINE__ << " | could not decode: "<< s_str_check << " | Token: " << s_token << "\n";
				return ast_test_patterns;
			}
			std::getline(s_string_stream, s_token, c_delim);
			st_test_pattern.x_fail = (s_token == "1");

			//Marker for the string token
			std::getline(s_string_stream, s_token, c_delim);
			s_str_check = "as_string_token";
			if (s_token != s_str_check)
			{
				std::cerr << "ERR:" << __LINE__ << " | could not decode: "<< s_str_check << " | Token: " << s_token << "\n";
				return ast_test_patterns;
			}
			//Get the size of the token vector from the fourth token of the line and convert it to size_t
			std::getline(s_string_stream, s_token, c_delim);
			n_size = std::stoul(s_token);
			//std::cout << "as_string_token size:" << n_size << "\n";
			//Loop through n_size tokens and add them to the token vector
			for (size_t i = 0; i < n_size; i++)
			{
				std::getline(s_string_stream, s_token, c_delim);
				st_test_pattern.as_string_token.push_back(s_token);
			}

			//Marker for the vector of token structures
			std::getline(s_string_stream, s_token, c_delim);
			s_str_check = "ast_token";
			if (s_token != s_str_check)
			{
				std::cerr << "ERR:" << __LINE__ << " | could not decode: "<< s_str_check << " | Token: " << s_token << "\n";
				return ast_test_patterns;
			}
			//Get the size of the vector
			std::getline(s_string_stream, s_token, c_delim);
			n_size = std::stoul(s_token);
			//std::cout << "as_string_token size:" << n_size << "\n";
			//Loop through n_size tokens and add them to the token vector
			for (size_t i = 0; i < n_size; i++)
			{
				//Check the marker for the token structure
				std::getline(s_string_stream, s_token, c_delim);
				s_str_check = "st_token";
				if (s_token != s_str_check)
				{
					std::cerr << "ERR:" << __LINE__ << " | could not decode: "<< s_str_check << " | Token: " << s_token << "\n";
					return ast_test_patterns;
				}
				//Parse a ful Token structure
				bool x_fail = parse_token( s_string_stream, st_token, c_delim );
				if (x_fail == true)
				{
					std::cerr << "ERR:" << __LINE__ << " | could not parse Token structure\n";
					return ast_test_patterns;
				}
				//Push the token inside the pattern
				st_test_pattern.ast_token.push_back(st_token);
			}
			//Get the size of the minimal node vector from the next token of the line and convert it to size_t
			std::getline(s_string_stream, s_token, c_delim);
			s_str_check = "ast_minimal_node";
			if (s_token != s_str_check)
			{
				std::cerr << "ERR:" << __LINE__ << " | could not decode: "<< s_str_check << " | Token: " << s_token << "\n";
				return ast_test_patterns;
			}
			std::getline(s_string_stream, s_token, c_delim);
			n_size = std::stoul(s_token);
			//Loop through n_size tokens and add them to the minimal node vector
			for (size_t i = 0; i < n_size; i++)
			{
				//Clear the payload object and set its fields to default values
				st_token = {};
				//Check special token
				std::getline(s_string_stream, s_token, c_delim);
				s_str_check = "st_minimal_node";
				if (s_token != s_str_check)
				{
					std::cerr << "ERR:" << __LINE__ << " | could not decode: "<< s_str_check << " | Token: " << s_token << "\n";
					return ast_test_patterns;
				}
				//Parse a Token structure, which is a member of the St_minimal_node structure
				bool x_fail = parse_token( s_string_stream, st_token, c_delim );
				if (x_fail == true)
				{
					std::cerr << "ERR:" << __LINE__ << " | could not parse Token structure\n";
					return ast_test_patterns;
				}
				//Get the index of the father from the next token of the line and convert it to size_t
				std::getline(s_string_stream, s_token, c_delim);
				n_index_father = std::stoul(s_token);
				//Create a minimal node object with the payload and the index of the father and add it to the minimal node vector
				st_test_pattern.ast_minimal_node.push_back({st_token, n_index_father});
			}
			//Get the user note from the first token of the line
			std::getline(s_string_stream, s_token, c_delim);
			s_str_check = "s_equation_decoded";
			if (s_token != s_str_check)
			{
				std::cerr << "ERR:" << __LINE__ << " | could not decode: "<< s_str_check << " | Token: " << s_token << "\n";
				return ast_test_patterns;
			}
			std::getline(s_string_stream, s_token, c_delim);
			st_test_pattern.s_equation_decoded = s_token.c_str();

			//Check special token
			std::getline(s_string_stream, s_token, c_delim);
			s_str_check = "END";
			if (s_token != s_str_check)
			{
				std::cerr << "ERR:" << __LINE__ << " | could not decode: "<< s_str_check << " | Token: " << s_token << "\n";
				return ast_test_patterns;
			}
			//Add the test pattern object to the vector of test patterns
			ast_test_patterns.push_back(st_test_pattern);
		}
	}
	else //If the file stream is not open
	{
		std::cerr << "Error: could not open file " << s_file_name << "\n";
	}
	//Close the file stream
	ifs.close();
	//Return the vector of test patterns
	return ast_test_patterns;
}

//! @brief write a Token structure inside a file stream
bool St_test_pattern::save_token( std::ofstream &ircl_file, User::Equation::Token &irst_token )
{
	//Write the payload string to the file, followed by a comma
	ircl_file << irst_token.cl_str << ",";
	//Write the payload type to the file, followed by a comma
	ircl_file << static_cast<int>(irst_token.e_type) << ",";
	//Write the payload open close priority to the file, followed by a comma
	ircl_file << irst_token.s32_open_close_priority << ",";
	//Write the payload symbol priority to the file, followed by a comma
	ircl_file << irst_token.s32_symbol_priority << ",";
	//Write the payload negative flag to the file, followed by a comma
	ircl_file << irst_token.u1_negative << ",";
	return false; //OK
}

//! @brief read from file a token and save it in a token structure
bool St_test_pattern::parse_token( std::stringstream &irs_string_stream, User::Equation::Token &orst_token, char &irs8_delimiter )
{
	//Temp string holding the token for the Token structure
	std::string s_token;
	//Get the payload string from the next token of the line
	std::getline(irs_string_stream, s_token, irs8_delimiter);
	orst_token.cl_str = s_token;
	//Get the payload type from the next token of the line and convert it to Token_type enum
	std::getline(irs_string_stream, s_token, irs8_delimiter);
	orst_token.e_type = static_cast<User::Equation::Token_type>(std::stoi(s_token));
	//Get the payload open close priority from the next token of the line and convert it to int
	std::getline(irs_string_stream, s_token, irs8_delimiter);
	orst_token.s32_open_close_priority = std::stoi(s_token);
	//Get the payload symbol priority from the next token of the line and convert it to int
	std::getline(irs_string_stream, s_token, irs8_delimiter);
	orst_token.s32_symbol_priority = std::stoi(s_token);
	//Get the payload negative flag from the next token of the line and convert it to bool
	std::getline(irs_string_stream, s_token, irs8_delimiter);
	orst_token.u1_negative = (s_token == "1");
	return false;	//OK
}

/**********************************************************************************
**  NAMESPACE
**********************************************************************************/

}	//end namespace


/*
//A tree holding just the root with an equal sign
const User::Tree<User::Equation::Token>::St_minimal_node cst_default_equal =
{
	User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("="), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },
};

//Create the test patterns alongside the expected result of the pattern. Can detect a misbehaviour of the parser
St_test_pattern ast_test_pattern[] =
{
	St_test_pattern{ "Empty String (FAIL)", "", true, std::vector<std::string>(), std::vector<User::Tree<User::Equation::Token>::St_minimal_node>( { cst_default_equal, } ) },
	St_test_pattern{ "Lack of equal sign (FAIL)", "1", true, std::vector<std::string>(), std::vector<User::Tree<User::Equation::Token>::St_minimal_node>( { cst_default_equal, } ) },
	St_test_pattern{ "Unbalanced brackets L (FAIL)", "(1", true, std::vector<std::string>(), std::vector<User::Tree<User::Equation::Token>::St_minimal_node>( { cst_default_equal, } ) },
	St_test_pattern{ "Unbalanced brackets R (FAIL)", "1(", true, std::vector<std::string>(), std::vector<User::Tree<User::Equation::Token>::St_minimal_node>( { cst_default_equal, } ) },
	St_test_pattern{ "Unbalanced brackets L (FAIL)", "((1)", true, std::vector<std::string>(), std::vector<User::Tree<User::Equation::Token>::St_minimal_node>( { cst_default_equal, } ) },
	St_test_pattern{ "Two equal signs (FAIL)", "1=1=1", true, std::vector<std::string>(), std::vector<User::Tree<User::Equation::Token>::St_minimal_node>( { cst_default_equal, } ) },
	St_test_pattern
	{
		"Balanced bracket (PASS)",
		"1=((((((1))))))",
		false,
		std::vector<std::string>
		(
			{
				std::string("1"),
				std::string("="),
				std::string("("),
				std::string("("),
				std::string("("),
				std::string("("),
				std::string("("),
				std::string("("),
				std::string("1"),
				std::string(")"),
				std::string(")"),
				std::string(")"),
				std::string(")"),
				std::string(")"),
				std::string(")")
			}
		),
		std::vector<User::Tree<User::Equation::Token>::St_minimal_node>
		(
			{
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("="), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("1"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("1"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 0, },
			}
		),

	},
	St_test_pattern
	{
		"Two Number Equation (PASS)",
		"1=1",
		false,
		std::vector<std::string>
		(
			{
				std::string("1"),
				std::string("="),
				std::string("1")
			}
		),
		std::vector<User::Tree<User::Equation::Token>::St_minimal_node>
		(
			{
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("="), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("1"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("1"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 0, },
			}
		),
	},
	St_test_pattern
	{
		"Floating Point Equation (PASS)",
		"3/2=1.5000000000",
		false,
		std::vector<std::string>
		(
			{
				std::string("3"),
				std::string("/"),
				std::string("2"),
				std::string("="),
				std::string("1.5000000000")
			}
		),
		std::vector<User::Tree<User::Equation::Token>::St_minimal_node>
		(
			{
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("="), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("/"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("1.5000000000"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("3"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 1, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("2"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 1, },
			}
		),
	},
	St_test_pattern
	{
		"Three Number Equation (PASS)",
		"5=2+3",
		false,
		std::vector<std::string>
		(
			{
				std::string("5"),
				std::string("="),
				std::string("2"),
				std::string("+"),
				std::string("3"),
			}
		),
		std::vector<User::Tree<User::Equation::Token>::St_minimal_node>
		(
			{
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("="), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("5"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("2"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 2, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("3"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 2, },
			}
		),
	},

	St_test_pattern
	{
		"Four Number Equation (PASS)",
		//Source equation string to be fed
		"A+B-C=100",
		//Expected failure state
		false,
		//Expected output of the tokenizer
		std::vector<std::string>
		(
			{
				std::string("A"),
				std::string("+"),
				std::string("B"),
				std::string("-"),
				std::string("C"),
				std::string("="),
				std::string("100"),
			}
		),
		//Expected output of the treeficator
		std::vector<User::Tree<User::Equation::Token>::St_minimal_node>
		(
			{
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("="), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("100"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 0, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("A"), User::Equation::Token_type::BASE_SYMBOL, 0, 0, false, }, 1, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("-"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 1, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("B"), User::Equation::Token_type::BASE_SYMBOL, 0, 0, false, }, 4, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("C"), User::Equation::Token_type::BASE_SYMBOL, 0, 0, false, }, 4, },
			}
		),
	},
	//Add symbols to equation
	St_test_pattern
	{
		"One Symbol Equation (PASS)",
		//Source equation string to be fed
		"X=1",
		//Expected failure state
		false,
		//Expected output of the tokenizer
		std::vector<std::string>
		(
			{
				std::string("X"),
				std::string("="),
				std::string("1"),
			}
		),
		//Expected output of the treeficator
		std::vector<User::Tree<User::Equation::Token>::St_minimal_node>
		(
			{
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("="), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("X"), User::Equation::Token_type::BASE_SYMBOL, 0, 0, false, }, 00, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("1"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 0, },
			}
		),
	},
	//! @todo * is higher priority than +, but is parsed in wrong order without brackets
	//Add more symbols to equation
	St_test_pattern
	{
		"Three Symbol Equation (PASS)",
		//Source equation string to be fed
		"3*X=(5*Y)+C",
		//Expected failure state
		false,
		//Expected output of the tokenizer
		std::vector<std::string>
		(
			{
				std::string("3"),
				std::string("*"),
				std::string("X"),
				std::string("="),
				std::string("("),
				std::string("5"),
				std::string("*"),
				std::string("Y"),
				std::string(")"),
				std::string("+"),
				std::string("C"),
			}
		),
		//Expected output of the treeficator
		std::vector<User::Tree<User::Equation::Token>::St_minimal_node>
		(
			{
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("="), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("*"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("3"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 1, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("X"), User::Equation::Token_type::BASE_SYMBOL, 0, 0, false, }, 1, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("*"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 2, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("C"), User::Equation::Token_type::BASE_SYMBOL, 0, 0, false, }, 2, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("5"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 5, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("Y"), User::Equation::Token_type::BASE_SYMBOL, 0, 0, false, }, 5, },
			}
		),
	},
	//long symbols
	St_test_pattern
	{
		"Long Symbol Equation (PASS)",
		//Source equation string to be fed
		"Pippo=Pluto+self_awareness",
		//Expected failure state
		false,
		//Expected output of the tokenizer
		std::vector<std::string>
		(
			{
				std::string("Pippo"),
				std::string("="),
				std::string("Pluto"),
				std::string("+"),
				std::string("self_awareness"),
			}
		),
		//Expected output of the treeficator
		std::vector<User::Tree<User::Equation::Token>::St_minimal_node>
		(
			{
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("="), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("Pippo"), User::Equation::Token_type::BASE_SYMBOL, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("Pluto"), User::Equation::Token_type::BASE_SYMBOL, 0, 0, false, }, 2, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("self_awareness"), User::Equation::Token_type::BASE_SYMBOL, 0, 0, false, }, 2, },
			}
		),
	},
	//TEST PATTERN 14
	St_test_pattern
	{
		"Sum aggregator (PASS)",
		//Source equation string to be fed
		"3=1+1+1",
		//Expected failure state
		false,
		//Expected output of the tokenizer
		std::vector<std::string>
		(
			{
				std::string("3"),
				std::string("="),
				std::string("1"),
				std::string("+"),
				std::string("1"),
				std::string("+"),
				std::string("1"),
			}
		),
		//Expected output of the treeficator
		std::vector<User::Tree<User::Equation::Token>::St_minimal_node>
		(
			{
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("="), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("3"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("1"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 2, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 2, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("1"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 4, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("1"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 4, },
			}
		),
	},
	//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	St_test_pattern
	{
		"Deep sum aggregator (PASS)",
		//Source equation string to be fed
		"28=1+2+3+4+5+6+7",
		//Expected failure state
		false,
		//Expected output of the tokenizer
		std::vector<std::string>
		(
			{
				std::string("28"),
				std::string("="),
				std::string("1"),
				std::string("+"),
				std::string("2"),
				std::string("+"),
				std::string("3"),
				std::string("+"),
				std::string("4"),
				std::string("+"),
				std::string("5"),
				std::string("+"),
				std::string("6"),
				std::string("+"),
				std::string("7"),
			}
		),
		//Expected output of the treeficator
		std::vector<User::Tree<User::Equation::Token>::St_minimal_node>
		(
			{
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("="), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("28"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("1"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 2, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 2, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("2"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 4, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 4, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("3"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 6, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 6, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("4"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 8, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 8, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("5"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 10, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 10, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("6"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 12, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("7"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 12, },
			}
		),
	},
	//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	St_test_pattern
	{
		"Deep diff with unary(PASS)",
		//Source equation string to be fed
		"-28=-1-2-3-4-5-6-7",
		//Expected failure state
		false,
		//Expected output of the tokenizer
		std::vector<std::string>
		(
			{
				std::string("28"),
				std::string("="),
				std::string("1"),
				std::string("-"),
				std::string("2"),
				std::string("-"),
				std::string("3"),
				std::string("-"),
				std::string("4"),
				std::string("-"),
				std::string("5"),
				std::string("-"),
				std::string("6"),
				std::string("-"),
				std::string("7"),
			}
		),
		//Expected output of the treeficator
		std::vector<User::Tree<User::Equation::Token>::St_minimal_node>
		(
			{
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("="), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("28"), User::Equation::Token_type::BASE_NUMBER, 0, 0, true, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("-"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("1"), User::Equation::Token_type::BASE_NUMBER, 0, 0, true, }, 2, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("-"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 2, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("2"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 4, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("-"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 4, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("3"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 6, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("-"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 6, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("4"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 8, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("-"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 8, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("5"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 10, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("-"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 10, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("6"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 12, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("7"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 12, },
			}
		),
	},
	//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	St_test_pattern
	{
		"Deep sum diff aggregator (PASS)",
		//Source equation string to be fed
		"4=1-2+3-4+5-6+7",
		//Expected failure state
		false,
		//Expected output of the tokenizer
		std::vector<std::string>
		(
			{
				std::string("4"),
				std::string("="),
				std::string("1"),
				std::string("-"),
				std::string("2"),
				std::string("+"),
				std::string("3"),
				std::string("-"),
				std::string("4"),
				std::string("+"),
				std::string("5"),
				std::string("-"),
				std::string("6"),
				std::string("+"),
				std::string("7"),
			}
		),
		//Expected output of the treeficator
		std::vector<User::Tree<User::Equation::Token>::St_minimal_node>
		(
			{
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("="), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("4"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("-"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("1"), User::Equation::Token_type::BASE_NUMBER, 0, 0, true, }, 2, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 2, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("2"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 4, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("-"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 4, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("3"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 6, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 6, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("4"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 8, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("-"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 8, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("5"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 10, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 10, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("6"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 12, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("7"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 12, },
			}
		),
	},
	//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	St_test_pattern
	{
		"Forced deep sum diff aggregator (PASS)",
		//Source equation string to be fed
		"4=((((((+1-2)+3)-4)+5)-6)+7)",
		//Expected failure state
		false,
		//Expected output of the tokenizer
		std::vector<std::string>
		(
			{
				std::string("4"),
				std::string("="),
				std::string("("),
				std::string("("),
				std::string("("),
				std::string("("),
				std::string("("),
				std::string("("),
				std::string("1"),
				std::string("-"),
				std::string("2"),
				std::string(")"),
				std::string("+"),
				std::string("3"),
				std::string(")"),
				std::string("-"),
				std::string("4"),
				std::string(")"),
				std::string("+"),
				std::string("5"),
				std::string(")"),
				std::string("-"),
				std::string("6"),
				std::string(")"),
				std::string("+"),
				std::string("7"),
				std::string(")"),
			}
		),
		//Expected output of the treeficator
		std::vector<User::Tree<User::Equation::Token>::St_minimal_node>
		(
			{
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("="), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("4"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("-"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 2, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("7"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 2, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 3, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("6"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 3, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("-"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 5, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("5"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 5, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 7, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("4"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 7, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("-"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 9, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("3"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 9, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("1"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 11, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("2"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 11, },
			}
		),
	},
	//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	St_test_pattern
	{
		"Forced deep sum diff aggregator (PASS)",
		//Source equation string to be fed
		"4=(+1-(2+(3-(4+(5-(6+(7)))))))",
		//Expected failure state
		false,
		//Expected output of the tokenizer
		std::vector<std::string>
		(
			{
				std::string("4"),
				std::string("="),
				std::string("("),
				std::string("1"),
				std::string("-"),
				std::string("("),
				std::string("2"),
				std::string("+"),
				std::string("("),
				std::string("3"),
				std::string("-"),
				std::string("("),
				std::string("4"),
				std::string("+"),
				std::string("("),
				std::string("5"),
				std::string("-"),
				std::string("("),
				std::string("6"),
				std::string("+"),
				std::string("("),
				std::string("7"),
				std::string(")"),
				std::string(")"),
				std::string(")"),
				std::string(")"),
				std::string(")"),
				std::string(")"),
				std::string(")"),
			}
		),
		//Expected output of the treeficator
		std::vector<User::Tree<User::Equation::Token>::St_minimal_node>
		(
			{
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("="), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("4"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("-"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("1"), User::Equation::Token_type::BASE_NUMBER, 0, 0, true, }, 2, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 2, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("2"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 4, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("-"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 4, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("3"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 6, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 6, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("4"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 8, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("-"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 8, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("5"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 10, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 10, },

				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("6"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 12, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("7"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 12, },
			}
		),
	},
	//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	St_test_pattern
	{
		"Complex sum aggregator (PASS)",
		//Source equation string to be fed
		"Y=1+(3*X)+2+(5*sephiroth +100 +101)+4",
		//Expected failure state
		false,
		//Expected output of the tokenizer
		std::vector<std::string>
		(
			{
				std::string("Y"),
				std::string("="),
				std::string("1"),
				std::string("+"),
				std::string("("),
				std::string("3"),
				std::string("*"),
				std::string("X"),
				std::string(")"),
				std::string("+"),
				std::string("2"),
				std::string("+"),
				std::string("("),
				std::string("5"),
				std::string("*"),
				std::string("sephiroth"),
				std::string("+"),
				std::string("100"),
				std::string("+"),
				std::string("101"),
				std::string(")"),
				std::string("+"),
				std::string("4"),
			}
		),
		//Expected output of the treeficator
		std::vector<User::Tree<User::Equation::Token>::St_minimal_node>
		(
			{
				//0
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("="), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("Y"), User::Equation::Token_type::BASE_SYMBOL, 0, 0, false, }, 0, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 0, },
				//3
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("1"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 2, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("*"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 2, },
				//5
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("*"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 4, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 4, },
				//7
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("3"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 5, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("X"), User::Equation::Token_type::BASE_SYMBOL, 0, 0, false, }, 5, },
				//9
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("2"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 6, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 6, },
				//11
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 10, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_OPERATOR, 0, 0, false, }, 10, },
				//13
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("5"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 11, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("sephiroth"), User::Equation::Token_type::BASE_SYMBOL, 0, 0, false, }, 11, },
				//15
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("5"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 6, },
				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("+"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 10, },


				User::Tree<User::Equation::Token>::St_minimal_node{ User::Equation::Token{ std::string("101"), User::Equation::Token_type::BASE_NUMBER, 0, 0, false, }, 11, },
			}
		),
	},


};	//Test pattern array
*/
